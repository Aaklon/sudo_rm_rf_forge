{"ast":null,"code":"import { collection, doc, addDoc, getDoc, getDocs, updateDoc, deleteDoc, query, where, orderBy, serverTimestamp, Timestamp } from 'firebase/firestore';\nimport { db } from '../firebase/config';\nclass BookingService {\n  // Create a new booking\n  async createBooking(userId, seatId, startTime, endTime, gracePeriod = 10) {\n    try {\n      const gracePeriodEnd = new Date(startTime.getTime() + gracePeriod * 60000);\n      const bookingRef = await addDoc(collection(db, 'bookings'), {\n        userId,\n        seatId: doc(db, 'seats', seatId),\n        startTime: Timestamp.fromDate(startTime),\n        endTime: Timestamp.fromDate(endTime),\n        gracePeriod,\n        gracePeriodEnd: Timestamp.fromDate(gracePeriodEnd),\n        status: 'pending',\n        createdAt: serverTimestamp(),\n        updatedAt: serverTimestamp()\n      });\n\n      // Update seat status\n      await updateDoc(doc(db, 'seats', seatId), {\n        status: 'booked',\n        currentBooking: bookingRef.id,\n        updatedAt: serverTimestamp()\n      });\n      return bookingRef.id;\n    } catch (error) {\n      console.error('Error creating booking:', error);\n      throw new Error('Failed to create booking');\n    }\n  }\n\n  // Get user bookings\n  async getUserBookings(userId) {\n    try {\n      const q = query(collection(db, 'bookings'), where('userId', '==', userId), orderBy('createdAt', 'desc'));\n      const snapshot = await getDocs(q);\n      const bookings = [];\n      for (const docSnap of snapshot.docs) {\n        const data = docSnap.data();\n        bookings.push({\n          id: docSnap.id,\n          ...data\n        });\n      }\n      return bookings;\n    } catch (error) {\n      console.error('Error fetching bookings:', error);\n      throw error;\n    }\n  }\n\n  // Get active booking for user\n  async getUserActiveBooking(userId) {\n    try {\n      const q = query(collection(db, 'bookings'), where('userId', '==', userId), where('status', 'in', ['pending', 'active']));\n      const snapshot = await getDocs(q);\n      if (snapshot.empty) return null;\n      const doc = snapshot.docs[0];\n      return {\n        id: doc.id,\n        ...doc.data()\n      };\n    } catch (error) {\n      console.error('Error fetching active booking:', error);\n      return null;\n    }\n  }\n\n  // Start session (mark as active)\n  async startSession(bookingId, userId) {\n    try {\n      const bookingRef = doc(db, 'bookings', bookingId);\n      const bookingDoc = await getDoc(bookingRef);\n      if (!bookingDoc.exists()) {\n        throw new Error('Booking not found');\n      }\n      const booking = bookingDoc.data();\n      if (booking.userId !== userId) {\n        throw new Error('Unauthorized');\n      }\n      await updateDoc(bookingRef, {\n        status: 'active',\n        actualStartTime: serverTimestamp(),\n        updatedAt: serverTimestamp()\n      });\n\n      // Update seat status\n      const seatId = typeof booking.seatId === 'object' ? booking.seatId.id : booking.seatId;\n      await updateDoc(doc(db, 'seats', seatId), {\n        status: 'occupied',\n        updatedAt: serverTimestamp()\n      });\n      return true;\n    } catch (error) {\n      console.error('Error starting session:', error);\n      throw error;\n    }\n  }\n\n  // Check out (end session)\n  async checkOut(bookingId, userId) {\n    try {\n      var _booking$actualStartT, _userData$stats, _userData$stats2, _userData$stats3;\n      const bookingRef = doc(db, 'bookings', bookingId);\n      const bookingDoc = await getDoc(bookingRef);\n      if (!bookingDoc.exists()) {\n        throw new Error('Booking not found');\n      }\n      const booking = bookingDoc.data();\n      if (booking.userId !== userId) {\n        throw new Error('Unauthorized');\n      }\n      const actualStartTime = ((_booking$actualStartT = booking.actualStartTime) === null || _booking$actualStartT === void 0 ? void 0 : _booking$actualStartT.toDate()) || booking.startTime.toDate();\n      const now = new Date();\n      const durationMs = now - actualStartTime;\n      const durationMins = Math.floor(durationMs / 60000);\n\n      // Calculate XP (1 XP per minute)\n      const xpEarned = Math.floor(durationMins);\n      await updateDoc(bookingRef, {\n        status: 'completed',\n        actualEndTime: serverTimestamp(),\n        duration: durationMins,\n        xpEarned,\n        updatedAt: serverTimestamp()\n      });\n\n      // Update user stats\n      const userRef = doc(db, 'users', userId);\n      const userDoc = await getDoc(userRef);\n      const userData = userDoc.data();\n      const newXP = (((_userData$stats = userData.stats) === null || _userData$stats === void 0 ? void 0 : _userData$stats.xp) || 0) + xpEarned;\n      const newLevel = Math.floor(newXP / 1000) + 1;\n      await updateDoc(userRef, {\n        'stats.xp': newXP,\n        'stats.level': newLevel,\n        'stats.totalMinutes': (((_userData$stats2 = userData.stats) === null || _userData$stats2 === void 0 ? void 0 : _userData$stats2.totalMinutes) || 0) + durationMins,\n        'stats.totalBookings': (((_userData$stats3 = userData.stats) === null || _userData$stats3 === void 0 ? void 0 : _userData$stats3.totalBookings) || 0) + 1,\n        updatedAt: serverTimestamp()\n      });\n\n      // Release seat\n      const seatId = typeof booking.seatId === 'object' ? booking.seatId.id : booking.seatId;\n      await updateDoc(doc(db, 'seats', seatId), {\n        status: 'available',\n        currentBooking: null,\n        updatedAt: serverTimestamp()\n      });\n      return {\n        xpEarned,\n        durationMins\n      };\n    } catch (error) {\n      console.error('Error checking out:', error);\n      throw error;\n    }\n  }\n\n  // Update booking\n  async updateBooking(bookingId, userId, updates) {\n    try {\n      const bookingRef = doc(db, 'bookings', bookingId);\n      const bookingDoc = await getDoc(bookingRef);\n      if (!bookingDoc.exists()) {\n        throw new Error('Booking not found');\n      }\n      const booking = bookingDoc.data();\n      if (booking.userId !== userId) {\n        throw new Error('Unauthorized');\n      }\n      if (booking.status !== 'pending') {\n        throw new Error('Can only update pending bookings');\n      }\n      const updateData = {\n        ...updates,\n        updatedAt: serverTimestamp()\n      };\n      if (updates.startTime) {\n        updateData.startTime = Timestamp.fromDate(updates.startTime);\n      }\n      if (updates.endTime) {\n        updateData.endTime = Timestamp.fromDate(updates.endTime);\n      }\n      await updateDoc(bookingRef, updateData);\n      return true;\n    } catch (error) {\n      console.error('Error updating booking:', error);\n      throw error;\n    }\n  }\n\n  // Cancel booking\n  async cancelBooking(bookingId) {\n    try {\n      const bookingRef = doc(db, 'bookings', bookingId);\n      const bookingDoc = await getDoc(bookingRef);\n      if (!bookingDoc.exists()) {\n        throw new Error('Booking not found');\n      }\n      const booking = bookingDoc.data();\n      await updateDoc(bookingRef, {\n        status: 'cancelled',\n        updatedAt: serverTimestamp()\n      });\n\n      // Release seat\n      const seatId = typeof booking.seatId === 'object' ? booking.seatId.id : booking.seatId;\n      await updateDoc(doc(db, 'seats', seatId), {\n        status: 'available',\n        currentBooking: null,\n        updatedAt: serverTimestamp()\n      });\n      return true;\n    } catch (error) {\n      console.error('Error cancelling booking:', error);\n      throw error;\n    }\n  }\n\n  // Check and process expired bookings\n  async checkAndProcessExpiredBookings(userId) {\n    try {\n      const q = query(collection(db, 'bookings'), where('userId', '==', userId), where('status', '==', 'pending'));\n      const snapshot = await getDocs(q);\n      const now = new Date();\n      for (const docSnap of snapshot.docs) {\n        const booking = docSnap.data();\n        const gracePeriodEnd = booking.gracePeriodEnd.toDate();\n        if (now > gracePeriodEnd) {\n          // Mark as no-show\n          await updateDoc(doc(db, 'bookings', docSnap.id), {\n            status: 'no_show',\n            updatedAt: serverTimestamp()\n          });\n\n          // Release seat\n          const seatId = typeof booking.seatId === 'object' ? booking.seatId.id : booking.seatId;\n          await updateDoc(doc(db, 'seats', seatId), {\n            status: 'available',\n            currentBooking: null,\n            updatedAt: serverTimestamp()\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error processing expired bookings:', error);\n    }\n  }\n}\nexport default new BookingService();","map":{"version":3,"names":["collection","doc","addDoc","getDoc","getDocs","updateDoc","deleteDoc","query","where","orderBy","serverTimestamp","Timestamp","db","BookingService","createBooking","userId","seatId","startTime","endTime","gracePeriod","gracePeriodEnd","Date","getTime","bookingRef","fromDate","status","createdAt","updatedAt","currentBooking","id","error","console","Error","getUserBookings","q","snapshot","bookings","docSnap","docs","data","push","getUserActiveBooking","empty","startSession","bookingId","bookingDoc","exists","booking","actualStartTime","checkOut","_booking$actualStartT","_userData$stats","_userData$stats2","_userData$stats3","toDate","now","durationMs","durationMins","Math","floor","xpEarned","actualEndTime","duration","userRef","userDoc","userData","newXP","stats","xp","newLevel","totalMinutes","totalBookings","updateBooking","updates","updateData","cancelBooking","checkAndProcessExpiredBookings"],"sources":["C:/Users/karan/Downloads/files/src/services/bookingService.js"],"sourcesContent":["import {\n  collection,\n  doc,\n  addDoc,\n  getDoc,\n  getDocs,\n  updateDoc,\n  deleteDoc,\n  query,\n  where,\n  orderBy,\n  serverTimestamp,\n  Timestamp\n} from 'firebase/firestore';\nimport { db } from '../firebase/config';\n\nclass BookingService {\n  // Create a new booking\n  async createBooking(userId, seatId, startTime, endTime, gracePeriod = 10) {\n    try {\n      const gracePeriodEnd = new Date(startTime.getTime() + gracePeriod * 60000);\n      \n      const bookingRef = await addDoc(collection(db, 'bookings'), {\n        userId,\n        seatId: doc(db, 'seats', seatId),\n        startTime: Timestamp.fromDate(startTime),\n        endTime: Timestamp.fromDate(endTime),\n        gracePeriod,\n        gracePeriodEnd: Timestamp.fromDate(gracePeriodEnd),\n        status: 'pending',\n        createdAt: serverTimestamp(),\n        updatedAt: serverTimestamp()\n      });\n\n      // Update seat status\n      await updateDoc(doc(db, 'seats', seatId), {\n        status: 'booked',\n        currentBooking: bookingRef.id,\n        updatedAt: serverTimestamp()\n      });\n\n      return bookingRef.id;\n    } catch (error) {\n      console.error('Error creating booking:', error);\n      throw new Error('Failed to create booking');\n    }\n  }\n\n  // Get user bookings\n  async getUserBookings(userId) {\n    try {\n      const q = query(\n        collection(db, 'bookings'),\n        where('userId', '==', userId),\n        orderBy('createdAt', 'desc')\n      );\n\n      const snapshot = await getDocs(q);\n      const bookings = [];\n\n      for (const docSnap of snapshot.docs) {\n        const data = docSnap.data();\n        bookings.push({\n          id: docSnap.id,\n          ...data\n        });\n      }\n\n      return bookings;\n    } catch (error) {\n      console.error('Error fetching bookings:', error);\n      throw error;\n    }\n  }\n\n  // Get active booking for user\n  async getUserActiveBooking(userId) {\n    try {\n      const q = query(\n        collection(db, 'bookings'),\n        where('userId', '==', userId),\n        where('status', 'in', ['pending', 'active'])\n      );\n\n      const snapshot = await getDocs(q);\n      \n      if (snapshot.empty) return null;\n      \n      const doc = snapshot.docs[0];\n      return { id: doc.id, ...doc.data() };\n    } catch (error) {\n      console.error('Error fetching active booking:', error);\n      return null;\n    }\n  }\n\n  // Start session (mark as active)\n  async startSession(bookingId, userId) {\n    try {\n      const bookingRef = doc(db, 'bookings', bookingId);\n      const bookingDoc = await getDoc(bookingRef);\n\n      if (!bookingDoc.exists()) {\n        throw new Error('Booking not found');\n      }\n\n      const booking = bookingDoc.data();\n      if (booking.userId !== userId) {\n        throw new Error('Unauthorized');\n      }\n\n      await updateDoc(bookingRef, {\n        status: 'active',\n        actualStartTime: serverTimestamp(),\n        updatedAt: serverTimestamp()\n      });\n\n      // Update seat status\n      const seatId = typeof booking.seatId === 'object' ? booking.seatId.id : booking.seatId;\n      await updateDoc(doc(db, 'seats', seatId), {\n        status: 'occupied',\n        updatedAt: serverTimestamp()\n      });\n\n      return true;\n    } catch (error) {\n      console.error('Error starting session:', error);\n      throw error;\n    }\n  }\n\n  // Check out (end session)\n  async checkOut(bookingId, userId) {\n    try {\n      const bookingRef = doc(db, 'bookings', bookingId);\n      const bookingDoc = await getDoc(bookingRef);\n\n      if (!bookingDoc.exists()) {\n        throw new Error('Booking not found');\n      }\n\n      const booking = bookingDoc.data();\n      if (booking.userId !== userId) {\n        throw new Error('Unauthorized');\n      }\n\n      const actualStartTime = booking.actualStartTime?.toDate() || booking.startTime.toDate();\n      const now = new Date();\n      const durationMs = now - actualStartTime;\n      const durationMins = Math.floor(durationMs / 60000);\n\n      // Calculate XP (1 XP per minute)\n      const xpEarned = Math.floor(durationMins);\n\n      await updateDoc(bookingRef, {\n        status: 'completed',\n        actualEndTime: serverTimestamp(),\n        duration: durationMins,\n        xpEarned,\n        updatedAt: serverTimestamp()\n      });\n\n      // Update user stats\n      const userRef = doc(db, 'users', userId);\n      const userDoc = await getDoc(userRef);\n      const userData = userDoc.data();\n      const newXP = (userData.stats?.xp || 0) + xpEarned;\n      const newLevel = Math.floor(newXP / 1000) + 1;\n\n      await updateDoc(userRef, {\n        'stats.xp': newXP,\n        'stats.level': newLevel,\n        'stats.totalMinutes': (userData.stats?.totalMinutes || 0) + durationMins,\n        'stats.totalBookings': (userData.stats?.totalBookings || 0) + 1,\n        updatedAt: serverTimestamp()\n      });\n\n      // Release seat\n      const seatId = typeof booking.seatId === 'object' ? booking.seatId.id : booking.seatId;\n      await updateDoc(doc(db, 'seats', seatId), {\n        status: 'available',\n        currentBooking: null,\n        updatedAt: serverTimestamp()\n      });\n\n      return { xpEarned, durationMins };\n    } catch (error) {\n      console.error('Error checking out:', error);\n      throw error;\n    }\n  }\n\n  // Update booking\n  async updateBooking(bookingId, userId, updates) {\n    try {\n      const bookingRef = doc(db, 'bookings', bookingId);\n      const bookingDoc = await getDoc(bookingRef);\n\n      if (!bookingDoc.exists()) {\n        throw new Error('Booking not found');\n      }\n\n      const booking = bookingDoc.data();\n      if (booking.userId !== userId) {\n        throw new Error('Unauthorized');\n      }\n\n      if (booking.status !== 'pending') {\n        throw new Error('Can only update pending bookings');\n      }\n\n      const updateData = {\n        ...updates,\n        updatedAt: serverTimestamp()\n      };\n\n      if (updates.startTime) {\n        updateData.startTime = Timestamp.fromDate(updates.startTime);\n      }\n      if (updates.endTime) {\n        updateData.endTime = Timestamp.fromDate(updates.endTime);\n      }\n\n      await updateDoc(bookingRef, updateData);\n      return true;\n    } catch (error) {\n      console.error('Error updating booking:', error);\n      throw error;\n    }\n  }\n\n  // Cancel booking\n  async cancelBooking(bookingId) {\n    try {\n      const bookingRef = doc(db, 'bookings', bookingId);\n      const bookingDoc = await getDoc(bookingRef);\n\n      if (!bookingDoc.exists()) {\n        throw new Error('Booking not found');\n      }\n\n      const booking = bookingDoc.data();\n\n      await updateDoc(bookingRef, {\n        status: 'cancelled',\n        updatedAt: serverTimestamp()\n      });\n\n      // Release seat\n      const seatId = typeof booking.seatId === 'object' ? booking.seatId.id : booking.seatId;\n      await updateDoc(doc(db, 'seats', seatId), {\n        status: 'available',\n        currentBooking: null,\n        updatedAt: serverTimestamp()\n      });\n\n      return true;\n    } catch (error) {\n      console.error('Error cancelling booking:', error);\n      throw error;\n    }\n  }\n\n  // Check and process expired bookings\n  async checkAndProcessExpiredBookings(userId) {\n    try {\n      const q = query(\n        collection(db, 'bookings'),\n        where('userId', '==', userId),\n        where('status', '==', 'pending')\n      );\n\n      const snapshot = await getDocs(q);\n      const now = new Date();\n\n      for (const docSnap of snapshot.docs) {\n        const booking = docSnap.data();\n        const gracePeriodEnd = booking.gracePeriodEnd.toDate();\n\n        if (now > gracePeriodEnd) {\n          // Mark as no-show\n          await updateDoc(doc(db, 'bookings', docSnap.id), {\n            status: 'no_show',\n            updatedAt: serverTimestamp()\n          });\n\n          // Release seat\n          const seatId = typeof booking.seatId === 'object' ? booking.seatId.id : booking.seatId;\n          await updateDoc(doc(db, 'seats', seatId), {\n            status: 'available',\n            currentBooking: null,\n            updatedAt: serverTimestamp()\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error processing expired bookings:', error);\n    }\n  }\n}\n\nexport default new BookingService();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}